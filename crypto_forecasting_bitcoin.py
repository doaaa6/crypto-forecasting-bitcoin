# -*- coding: utf-8 -*-
"""crypto-forecasting-bitcoin.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1L5JHhnpJRdgSb8sGoKEWc_c0IWAAXxM9
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd

df = pd.read_csv('/content/drive/MyDrive/DS-Project-Doaa FATHALLAH-FIN 2/crypto-forecasting-bitcoin-dataset.csv')

import numpy as np

df_dirty = df.copy()
np.random.seed(42)
for col in ['Open','High','Low','Close','Volume']:
    df_dirty.loc[df_dirty.sample(frac=0.05).index, col] = np.nan

from sklearn.impute import SimpleImputer

X = df_dirty[['Open','High','Low','Close','Volume']]
imputer = SimpleImputer(strategy='mean')
X_clean = pd.DataFrame(imputer.fit_transform(X), columns=X.columns)

# Add back the date if needed
X_clean['Date'] = df_dirty['Timestamp']
X_clean.head()

import matplotlib.pyplot as plt
import seaborn as sns

# Price evolution
plt.figure(figsize=(12,4))
plt.plot(X_clean['Date'], X_clean['Close'])
plt.title('Bitcoin Close Price Evolution')
plt.xlabel('Date'); plt.ylabel('Price')
plt.show()

# Histogram of daily returns
X_clean['log_return'] = np.log(X_clean['Close']).diff()
sns.histplot(X_clean['log_return'].dropna(), bins=100, kde=True)
plt.title('Distribution of log returns')
plt.show()

# Correlation heatmap
sns.heatmap(X_clean[['Open','High','Low','Close','Volume']].corr(), annot=True, cmap='coolwarm')
plt.title('Feature Correlations')
plt.show()

holdout = 180  # last 180 days as test
train = X_clean.iloc[:-holdout]
test = X_clean.iloc[-holdout:]

X_train = train.drop(columns=['Date','log_return'])
y_train = train['log_return']
X_test = test.drop(columns=['Date','log_return'])
y_test = test['log_return']

from lightgbm import LGBMRegressor
from sklearn.metrics import mean_squared_error
import numpy as np # Import numpy for sqrt

model = LGBMRegressor(n_estimators=500, random_state=42)
model.fit(X_train, y_train)
y_pred = model.predict(X_test)

# Calculate MSE and then take the square root to get RMSE
mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)
print(f'Test RMSE: {rmse:.5f}')

import matplotlib.pyplot as plt
import seaborn as sns

# Price evolution
plt.figure(figsize=(12,4))
plt.plot(X_clean['Date'], X_clean['Close'])
plt.title('Bitcoin Close Price Evolution')
plt.xlabel('Date'); plt.ylabel('Price')
plt.show()

# Histogram of daily returns
X_clean['log_return'] = np.log(X_clean['Close']).diff()
sns.histplot(X_clean['log_return'].dropna(), bins=100, kde=True)
plt.title('Distribution of log returns')
plt.show()

# Correlation heatmap
sns.heatmap(X_clean[['Open','High','Low','Close','Volume']].corr(), annot=True, cmap='coolwarm')
plt.title('Feature Correlations')
plt.show()

holdout = 180  # last 180 days as test
train = X_clean.iloc[:-holdout]
test = X_clean.iloc[-holdout:]

X_train = train.drop(columns=['Date','log_return'])
y_train = train['log_return']
X_test = test.drop(columns=['Date','log_return'])
y_test = test['log_return']

from lightgbm import LGBMRegressor
from sklearn.metrics import mean_squared_error
import numpy as np # Import numpy for sqrt

model = LGBMRegressor(n_estimators=500, random_state=42)
model.fit(X_train, y_train)
y_pred = model.predict(X_test)

# Calculate MSE and then take the square root to get RMSE
mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)
print(f'Test RMSE: {rmse:.5f}')

plt.figure(figsize=(12,4))
plt.plot(test['Date'], y_test, label='Actual')
plt.plot(test['Date'], y_pred, label='Predicted')
plt.title('Bitcoin log return: Actual vs Predicted')
plt.legend()
plt.show()

importances = pd.Series(model.feature_importances_, index=X_train.columns).sort_values(ascending=False)
importances.plot(kind='barh'); plt.gca().invert_yaxis(); plt.title('Feature Importance')
plt.show()